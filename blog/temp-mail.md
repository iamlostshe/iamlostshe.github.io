мне нужно написать скрипт **авторега аккаунтов** для одного популярного сервиса. логичным решением было использовать **временные почты**.

ранее (~1.5 года назад) я уже использовал для таких задач python-библиотеку [tempmail](https://github.com/cubicbyte/tempmail-python), но она [перестала работать](https://github.com/cubicbyte/tempmail-python/issues/13).

в моей [issue](https://github.com/cubicbyte/tempmail-python/issues/13) к [tempmail](https://github.com/cubicbyte/tempmail-python) предложили [альтернативу](https://github.com/MainSilent/MailTm).

но в связи с устаревшими решениями по коду я решил [форкнуть](https://github.com/iamlostshe/mail-tm) либу. Оказалось, что механизм библиотеки достаточно прост - она использует [открытые api](https://api.mail.tm/) сервиса mail.tm.

проведя небольшой ресёрч в интернете я нашел сервис mail.gw, который выглядит/работает также, как mail.tm и с которым, как оказалось, уже может работать [мой форк](https://github.com/iamlostshe/mail-tm).

но, есть проблема: при регистрации аккаунта сервис легко обнаруживает временные почты (предположительно, по черному списку доменов).

значит нам предстоит развернуть собственный сервер временной электронной почты на собственном домене.

у меня есть бесплатный безлимитный запас доменов 3-го уровня (domain.domain.com). но я не уверен что на таком домене можно поднять почту/редирект (по крайней мере ни разу не видел почт вида support@domain.domain.com, хотя возможно это просто никому не нужно).

исходный код сервера mail.tm и mail.gw (предположительно) был опубликован на GitHub. по крайней мере так было с [документацией](https://docs.mail.tm/), но с 2022 года или ранее недоступен (определил по архивным копиям).

запрос на почты поддержки (support@mail.tm, support@mail.qw), в [дс/тг](https://discord.com/invite/mail) не дал результатов (мне не ответили).

из этого можно сделать вывод: исходный код серверной части можно считать закрытым, а значит нам нужно написать свой.

продолжая пост об авторегах и временных [почтах](https://t.me/iamlostshe_blog/47):

проводя ресёрч информации о сервисе в интернете, я наткнулся, на github репозиторий двухлетней давности, представляющий из себя асинхронную python-обёртку для `api` сервиса.

автор репозитория откопал openapi документацию, в ходе реверс инженеринга запросов на телефоне.

разведывая openapi сервиса, я наткнулся на метод для авторизации по системе логин/пароль и вспомнил, что там до сих пор нет, ни подтверждения через почту/номер телефона, ни двухфакторной аутентификации.

значит для брута аккаунтов нам нужно где-то взять базу ников пользователей.

раньше, ради интереса я писал парсер, собирающий всю базу логинов пользователей сервиса. но была у скрипта одна проблема, которая не дала мне тогда закончить исследование - время. это было связано с ограничениями сервиса, нужно было минимум 5 секунд между запросами, во избежание блокировок.

немного переписав скрипт (там был ужас по коду) я запустил сбор логинов.

при первом запуске, собрав почти треть юзернеймов, я потерял базу из-за отключения электричества.

но со второго раза всё получилось.

``` md
всего собрано ников: 2 122 083.
всего собрано страниц: 9 844.
```

время на парсинг всех ников: ~14 часов

интересно то, что много людей указывают номера телефона в качестве ника, сомнительное решение.. я подсуетился и написал скрипт для поиска телефонных номеров в никах:

всего собрано номеров: 4958, 0.23% (от собранных ников).

ник = номер: 3657, 73.8% (от найденных номеров).
номер в конце: 667, 13.5% (от найденных номеров).
номер в начале: 595, 12% (от найденных номеров).
другое: 39, 0.8% (от найденных номеров).

также, скриптом для поиска аномалий найдены 4 ника (данные анонимизированы):

``` md
'https://example.com/user/7777777777 '
'https://example.com/user/iamlostshe1\n'
'https://example.com/user/iamlostshit\n'
'https://example.com/user/iamlost_aim\n'
```

из интересных символов здесь фигурирует ' ' (пробел) и '\n' (символ переноса строки).

> кстати, первая страница переводит на тех. работы.

> будет круто оставить отслку, в авторегах и регистрировать все аккаунты с ником, типа:
>
> `iamlostshe_1\n`

аномалии больше похожи на непроизвольные, как минимум потому, что профили людей выглядят настоящими и не связаны с программированием.

даты регистрации аномальных аккаунтов разбросаны, последняя - май 2025, а это значит, что скорее всего до сих пор можно делать интересные ники.

что дальше?

1. попробую зарегистрировать аккаунт с пробелом или переносом строки, кириллическими символами. посмотрим, как на это будут реагировать люди/администраторы сервиса. (по крайней мере метод апи, отвечающий за проверку доступности ника не ругается на "яемлосше").

> ник с пробелом зарегистрировать не даёт. аккаунты со '\n' регистрируются, '\n' считается за один символ (минимум 4) и любое кол-во '\n' считается занятым ником (то есть нужно добавить что-то в начале/конце/посередине).

2. попытаюсь брутить акки. cпойлер: меня (спойлер: не только меня) заблокировали по ip, видимо плохой идеей было посылать 20 запросов за минуту с одного ip. значится, собираем ботнет..

3. продолжая ветку авторегов: в `api` есть метод для регистрации аккаунта, он не просит почты/номера телефона, но возможно предоставляет ограниченные возможности (однако, возможно их можно обойти напрямую через `api`).

4. нужно задуматься о прокси (желательно мобильных). для брута и авторегов пригодится.

проводя ресёрч решений по поднятию собственной python-совместимой почты, я наткнулся на старенькую [статью на habr](https://habr.com/ru/articles/143241/) о библиотеке [inbox.py](https://github.com/billzhong/inbox.py), которая позиционирует себя как простой почтовый smtp-сервер для людей.

интересный факт: в контрибьюторах библиотеки числится создатель requests (популярной библиотеки для парсинга).

когда я попытался развернуть локальный почтовый сервер с помощью библиотеки, оказалось, что она давно не поддерживается и не может работать с python версии 3.12 и выше.

логичным решением было [форкнуть](https://github.com/iamlostshe/inboxium) библиотеку, обновив зависимости (переписал на aiosmtpd).

теперь она работает в современном python (и называется [inboxium](https://github.com/iamlostshe/inboxium)).

поднял почту на VDS.

ради интереса решил отправить письмо, просто, по ip (admin@0.0.0.0) - работает. не знал, что так можно, по крайней мере ни разу не видел чтобы так делали.

но, к моему удивлению на моём домене третьего уровня работать отказалось.

для того чтобы понять в чём была проблема, немного введу в курс:

я арендую сервер у одного популярного хостинга, любой пользователь которого может зарегистрировать на себя технический (тестовый) домен (example.hoster.com) третьего уровня или выше.

оказалось, что проблема была в том, что в MX записях у домена указаны сервера хостинга (mx.hostname.com), а не мои и изменить их я не могу.

в этот момент мне стало интересно сколько таких служебных доменов зарегистрировано. и мы можем узнать с помощью утилиты для поиска доменов 3-го уровня и выше - subfinder:

``` bash
subfinder -d hoster.com
```

всего зарегистрировано 2464 домена (я ожидал больше), 394 из них - просто дубликаты с `www.`. на 905 из них действительно было что-то поднято: реальные тестовые версии сайтов/`api`, пустые страницы (404), админки, гит-репозитории и многое другое, в общем ничего интересного.

очень много случайно сгенерированных, типа, `1535453-cx84936.hoster.com`.

самый длинный из них:

```
node-tvkrdsmneteh3a7l5tgx68mwf5s0jzzqwhkawm7fzvjmdlckeqr8coq2.dcszhwnh8ieodntwm42pnvdv24avb0kqua6i8i6zvk9406s8zu3kvgtf.hoster.com
```

скорее всего это не все домены, т. к. я не нашёл свои. возможно, у subfinder есть технические ограничения.

значит нужно просто купить домен и прописать ip сервера в DNS (однако, меня всё ещё смущает необходимость ввода паспортных данныx для регистрации).

после успешной покупки домена и проброса MX записей в DNS мы имеем рабочую почту на домене 3-го уровня.

но проблемы начались с другой стороны:

для подтверждения почты сервис отправляет сообщение, в формате, который библиотека считает пустым текстом.

это значит, что нам придётся переписать механизм препарирования сообщений (чтобы пользователь мог получить сырые данные).

и ещё я давно хотел сделать структуру работы с сообщениями как в [aiogram](https://pypi.org/project/aiogram), чтобы был единый класс message и разработчик мог получить из него всё остальное:

``` python
by: str | получатель (-и).
sender: str | отправитель.
subject: str | тема письма.
text: str | текст письма.
raw: str | сырой текст письма (для таких случаев как наш).
```

вот пример кода на обновлённом [inboxium](https://github.com/iamlostshe/inboxium):

``` python
@inbox.message
async def handle(message: InboxMessage) -> None:
    """Handle any messages."""
    if message.sender == TARGET_SENDER:
        print("!!! Верно обнаружен отправитель !!!")

        urls = re.findall(FIND_CONFIDER_URL, message.raw)
        if urls:
            r = requests.get(urls[0])
            print(f"!!! Почта подтверждена {urls[0]} !!!")
```

кстати, заметил, что в стандартных классах современного python, связанных с email отвратительное оформление кода. так что даже в питоне есть еще что форкать))

для удобства работы, систему было решено сделать автономной:

на VDS с белым IP поднят скрипт, который сверяет отправителя и тему письма и переходит по ссылкам для подтверждения почты.
