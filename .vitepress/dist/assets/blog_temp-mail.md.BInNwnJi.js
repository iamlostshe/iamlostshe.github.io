import{_ as a,c as i,o as t,ae as p}from"./chunks/framework.BD_Yrv4e.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"blog/temp-mail.md","filePath":"blog/temp-mail.md"}'),e={name:"blog/temp-mail.md"};function n(l,s,r,h,o,k){return t(),i("div",null,[...s[0]||(s[0]=[p(`<p>мне нужно написать скрипт <strong>авторега аккаунтов</strong> для одного популярного сервиса. логичным решением было использовать <strong>временные почты</strong>.</p><p>ранее (~1.5 года назад) я уже использовал для таких задач python-библиотеку <a href="https://github.com/cubicbyte/tempmail-python" target="_blank" rel="noreferrer">tempmail</a>, но она <a href="https://github.com/cubicbyte/tempmail-python/issues/13" target="_blank" rel="noreferrer">перестала работать</a>.</p><p>в моей <a href="https://github.com/cubicbyte/tempmail-python/issues/13" target="_blank" rel="noreferrer">issue</a> к <a href="https://github.com/cubicbyte/tempmail-python" target="_blank" rel="noreferrer">tempmail</a> предложили <a href="https://github.com/MainSilent/MailTm" target="_blank" rel="noreferrer">альтернативу</a>.</p><p>но в связи с устаревшими решениями по коду я решил <a href="https://github.com/iamlostshe/mail-tm" target="_blank" rel="noreferrer">форкнуть</a> либу. Оказалось, что механизм библиотеки достаточно прост - она использует <a href="https://api.mail.tm/" target="_blank" rel="noreferrer">открытые api</a> сервиса mail.tm.</p><p>проведя небольшой ресёрч в интернете я нашел сервис mail.gw, который выглядит/работает также, как mail.tm и с которым, как оказалось, уже может работать мой форк. (<a href="https://github.com/iamlostshe/mail-tm" target="_blank" rel="noreferrer">https://github.com/iamlostshe/mail-tm</a>)</p><p>но, есть проблема: при регистрации аккаунта сервис легко обнаруживает временные почты (предположительно, по черному списку доменов).</p><p>значит нам предстоит развернуть собственный сервер временной электронной почты на собственном домене.</p><p>у меня есть бесплатный безлимитный запас доменов 3-го уровня (domain.domain.com). но я не уверен что на таком домене можно поднять почту/редирект (по крайней мере ни разу не видел почт вида <a href="mailto:support@domain.domain.com" target="_blank" rel="noreferrer">support@domain.domain.com</a>, хотя возможно это просто никому не нужно).</p><p>исходный код сервера mail.tm и mail.gw (предположительно) был опубликован на GitHub. по крайней мере так было с документацией, (<a href="https://docs.mail.tm/" target="_blank" rel="noreferrer">https://docs.mail.tm/</a>) но с 2022 года или ранее недоступен (определил по архивным копиям).</p><p>запрос на почты поддержки (<a href="mailto:support@mail.tm" target="_blank" rel="noreferrer">support@mail.tm</a>, support@mail.qw), в дс/тг (<a href="https://discord.com/invite/mail" target="_blank" rel="noreferrer">https://discord.com/invite/mail</a>) не дал результатов (мне не ответили).</p><p>из этого можно сделать вывод: исходный код серверной части можно считать закрытым, а значит нам нужно написать свой.</p><p>продолжая пост об авторегах и временных почтах (<a href="https://t.me/iamlostshe_blog/47" target="_blank" rel="noreferrer">https://t.me/iamlostshe_blog/47</a>):</p><p>проводя ресёрч информации о сервисе в интернете, я наткнулся, на github репозиторий двухлетней давности, представляющий из себя асинхронную python-обёртку для <code>api</code> сервиса.</p><p>автор репозитория откопал openapi документацию, в ходе реверс инженеринга запросов на телефоне.</p><p>разведывая openapi сервиса, я наткнулся на метод для авторизации по системе логин/пароль и вспомнил, что там до сих пор нет, ни подтверждения через почту/номер телефона, ни двухфакторной аутентификации.</p><p>значит для брута аккаунтов нам нужно где-то взять базу ников пользователей.</p><p>раньше, ради интереса я писал парсер, собирающий всю базу логинов пользователей сервиса. но была у скрипта одна проблема, которая не дала мне тогда закончить исследование - время. это было связано с ограничениями сервиса, нужно было минимум 5 секунд между запросами, во избежание блокировок.</p><p>немного переписав скрипт (там был ужас по коду) я запустил сбор логинов.</p><p>при первом запуске, собрав почти треть юзернеймов, я потерял базу из-за отключения электричества.</p><p>но со второго раза всё получилось.</p><p>всего собрано ников: 2 122 083. всего собрано страниц: 9 844.</p><p>время на парсинг всех ников: ~14 часов</p><p>интересно то, что много людей указывают номера телефона в качестве ника, сомнительное решение.. я подсуетился и написал скрипт для поиска телефонных номеров в никах:</p><p>всего собрано номеров: 4958, 0.23% (от собранных ников).</p><p>ник = номер: 3657, 73.8% (от найденных номеров). номер в конце: 667, 13.5% (от найденных номеров). номер в начале: 595, 12% (от найденных номеров). другое: 39, 0.8% (от найденных номеров).</p><p>также, скриптом для поиска аномалий найдены 4 ника (данные анонимизированы):</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&#39;https://example.com/user/7777777777 &#39;</span></span>
<span class="line"><span>&#39;https://example.com/user/iamlostshe1\\n&#39;</span></span>
<span class="line"><span>&#39;https://example.com/user/iamlostshit\\n&#39;</span></span>
<span class="line"><span>&#39;https://example.com/user/iamlost_aim\\n&#39;</span></span></code></pre></div><blockquote><p>Будет круто оставить отслку, в авторегах и регистрировать все аккаунты с ником, типа:</p><p><code>iamlostshe_11\\n</code></p></blockquote><p>из интересных символов здесь фигурирует &#39; &#39; (пробел) и &#39;\\n&#39; (символ переноса строки).</p><blockquote><p>кстати, первая страница переводит на тех. работы.</p></blockquote><p>аномалии больше похожи на непроизвольные, как минимум потому, что профили людей выглядят настоящими и не связаны с программированием.</p><p>даты регистрации аномальных аккаунтов разбросаны, последняя - май 2025, а это значит, что скорее всего до сих пор можно делать интересные ники.</p><p>что дальше?</p><ol><li>попробую зарегистрировать аккаунт с пробелом или переносом строки, кириллическими символами. посмотрим, как на это будут реагировать люди/администраторы сервиса. (по крайней мере метод апи, отвечающий за проверку доступности ника не ругается на &quot;яемлосше&quot;).</li></ol><blockquote><p>ник с пробелом зарегистрировать не даёт. аккаунты со &#39;\\n&#39; регистрируются, &#39;\\n&#39; считается за один символ (минимум 4) и любое кол-во &#39;\\n&#39; считается занятым ником (то есть нужно добавить что-то в начале/конце/посередине).</p></blockquote><ol start="2"><li><p>попытаюсь брутить акки. cпойлер: меня (спойлер: не только меня) заблокировали по ip, видимо плохой идеей было посылать 20 запросов за минуту с одного ip. значится, собираем ботнет..</p></li><li><p>продолжая ветку авторегов: в <code>api</code> есть метод для регистрации аккаунта, он не просит почты/номера телефона, но возможно предоставляет ограниченные возможности (однако, возможно их можно обойти напрямую через <code>api</code>).</p></li><li><p>нужно задуматься о прокси (желательно мобильных). для брута и авторегов пригодится.</p></li></ol><p>проводя ресёрч решений по поднятию собственной python-совместимой почты, я наткнулся на старенькую статью на habr (<a href="https://habr.com/ru/articles/143241/" target="_blank" rel="noreferrer">https://habr.com/ru/articles/143241/</a>) о библиотеке inbox.py (<a href="https://github.com/billzhong/inbox.py" target="_blank" rel="noreferrer">https://github.com/billzhong/inbox.py</a>), которая позиционирует себя как простой почтовый smtp-сервер для людей.</p><p>интересный факт: в контрибьюторах библиотеки числится создатель requests (популярной библиотеки для парсинга).</p><p>когда я попытался развернуть локальный почтовый сервер с помощью библиотеки, оказалось, что она давно не поддерживается и не может работать с python версии 3.12 и выше.</p><p>логичным решением было форкнуть (<a href="https://github.com/iamlostshe/inboxium" target="_blank" rel="noreferrer">https://github.com/iamlostshe/inboxium</a>) библиотеку, обновив зависимости (переписал на aiosmtpd).</p><p>теперь она работает в современном python (и называется inboxium (<a href="https://github.com/iamlostshe/inboxium" target="_blank" rel="noreferrer">https://github.com/iamlostshe/inboxium</a>)).</p><p>поднял почту на VDS.</p><p>ради интереса решил отправить письмо, просто, по ip (<a href="mailto:admin@0.0.0.0" target="_blank" rel="noreferrer">admin@0.0.0.0</a>) - работает. не знал, что так можно, по крайней мере ни разу не видел чтобы так делали.</p><p>но, к моему удивлению на моём домене третьего уровня работать отказалось.</p><p>для того чтобы понять в чём была проблема, немного введу в курс:</p><p>я арендую сервер у одного популярного хостинга, любой пользователь которого может зарегистрировать на себя технический (тестовый) домен (example.hoster.com) третьего уровня или выше.</p><p>оказалось, что проблема была в том, что в MX записях у домена указаны сервера хостинга (mx.hostname.com), а не мои и изменить их я не могу.</p><p>в этот момент мне стало интересно сколько таких служебных доменов зарегистрировано. и мы можем узнать с помощью утилиты для поиска доменов 3-го уровня и выше - subfinder:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>subfinder -d hoster.com</span></span></code></pre></div><p>всего зарегистрировано 2464 домена (я ожидал больше), 394 из них - просто дубликаты с &#39;www.&#39;. на 905 из них действительно было что-то поднято: реальные тестовые версии сайтов/<code>api</code>, пустые страницы (404), админки, гит-репозитории и многое другое, в общем ничего интересного.</p><p>очень много случайно сгенерированных, типа, 1535453-cx84936.hoster.com.</p><p>самый длинный из них:</p><p>node-tvkrdsmneteh3a7l5tgx68mwf5s0jzzqwhkawm7fzvjmdlckeqr8coq2.dcszhwnh8ieodntwm42pnvdv24avb0kqua6i8i6zvk9406s8zu3kvgtf.hoster.com</p><p>скорее всего это не все домены, т. к. я не нашёл свои. возможно, у subfinder есть ограничения.</p><p>значит нужно просто купить домен и прописать ip сервера в DNS (однако, меня всё ещё смущает необходимость ввода паспортных данныx для регистрации).</p><p>после успешной покупки домена и проброса MX записей в DNS мы имеем рабочую почту на домене 3-го уровня.</p><p>но проблемы начались с другой стороны:</p><p>для подтверждения почты сервис отправляет сообщение, в формате, который библиотека считает пустым текстом.</p><p>это значит, что нам придётся переписать механизм препарирования сообщений (чтобы пользователь мог получить сырые данные).</p><p>и ещё я давно хотел сделать структуру работы с сообщениями как в <a href="https://pypi.org/project/aiogram" target="_blank" rel="noreferrer">aiogram</a>, чтобы был единый класс message и разработчик мог получить из него всё остальное:</p><p>by (str): получатель (-и). sender (str): отправитель. subject (str): тема письма. text (str): текст письма. raw (str): сырой текст письма (для таких случаев как наш).</p><p>вот пример кода на обновлённом <a href="https://github.com/iamlostshe/inboxium" target="_blank" rel="noreferrer">inboxium</a>:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@inbox.message</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(message: InboxMessage) -&gt; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">None</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;Handle any messages.&quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> message.sender </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TARGET_SENDER</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;!!! Верно обнаружен отправитель !!!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        urls </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> re.findall(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FIND_CONFIDER_URL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, message.raw)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> urls:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> requests.get(urls[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;!!! Почта подтверждена </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">{</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">urls[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">}</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> !!!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>кстати, заметил, что в стандартных классах современного python, связанных с email отвратительное оформление кода. так что даже в питоне есть еще что форкать))</p><p>для удобства работы, систему было решено сделать автономной:</p><p>на VDS с белым IP поднят скрипт, который сверяет отправителя и тему письма и переходит по ссылкам для подтверждения почты.</p>`,66)])])}const c=a(e,[["render",n]]);export{g as __pageData,c as default};
